<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Dynamic Programming</title>
        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/night.css" id="theme">
        
       
        <!-- For syntax highlighting -->
        <link rel="stylesheet" href="lib/css/Zenburn.css">

        

        <!-- If the query includes 'print-pdf', use the PDF print sheet -->
        <script>
          document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
        </script>

        <style type="text/css">
            @page {    
              margin: 0;
              size: auto; 
            }
        </style>

        <script>
         if(window.location.search.match( /print-pdf-now/gi )) {
           window.print();
         }
      </script>

    </head>
    <body>

        <div class="reveal">
            <div class="slides"><section  data-markdown><script type="text/template">### 15. Dynamic Programming 1

Masahiro Matsui
</script></section><section  data-markdown><script type="text/template">
画像など以下から引用しています。

Thomas H. Cormen  (著), Charles E. Leiserson  (著), Ronald L. Rivest  (著), Clifford Stein  (著) Introduction to Algorithms (The MIT Press) 
</script></section><section ><section data-markdown><script type="text/template">
#### Dynamic Programming ?
</script></section><section data-markdown><script type="text/template">
- 部分問題の解を合わせて問題を解く

- ↑ ここまでは分割統治法（マージソートなど）と同じ
</script></section><section data-markdown><script type="text/template">
##### 分割統治法との違い

- 表埋めによって部分問題の重複を効率よく処理する

- Dynamic Programming の Programming は表埋めの意味（コーディングの意味ではない）
</script></section><section data-markdown><script type="text/template">
- 典型的には最小化、最大化といった最適化問題に適用される
- **an** optimal solution を探す (not **the** optimal solution)
</script></section><section data-markdown><script type="text/template">
##### 4 Steps

1. 最適解の構造を特徴付ける
2. 再帰的に最適解を定義
3. （典型的には）ボトムアップで（基底部から）最適解の **値** を計算
4. 計算結果（表）から最適解（どういったプロセスで3の値が得られるか）を構成 
</script></section><section data-markdown><script type="text/template">
- 4は最適解の値のみ欲しい場合は不要
- 4が必要な場合、しばしば3で追加情報を記録
- 15章 2、4節では明確にStepに従っている
</script></section></section><section ><section data-markdown><script type="text/template">
#### 15.1 Rod cutting

![長さと値段の対応表](../images/algo/rod01.png)

長さと値段の対応表が与えられるので、ある長さの棒の値段を最大化する分割の方法を考える
</script></section><section data-markdown><script type="text/template">
例）長さ4の棒の分割方法 全通り

![長さ4の棒の分割方法](../images/algo/rod02.png)

切れる可能性のある部分が $n-1$ 箇所なので、そこで切るか切らないかを考えて $2^{n-1}$
</script></section><section data-markdown><script type="text/template">
- $nondecreasing$ な並びの切り方をしたい場合、場合の数は partition function 、分割数となる。
- $e^{\pi \sqrt{2n/3}}/4n\sqrt3$ で近似できる。
- ただ、これでも多項式オーダーにはならない。
</script></section><section data-markdown><script type="text/template">
- 長さiの時の値段と切り方

![長さiの時の値段と切り方](../images/algo/rod03.png)
</script></section><section data-markdown><script type="text/template">
式にすると

![式]](../images/algo/rod04.png)
![式](../images/algo/rod05.png)

一つの部分問題に依存
</script></section></section><section ><section data-markdown><script type="text/template">
##### Recursive top-down implementation 

素直に再帰的に式を実装すると

![rec](../images/algo/rod06.png)
</script></section><section data-markdown><script type="text/template">
再帰呼び出しを木で表すと

![rec_tree](../images/algo/rod07.png)

2が複数あるなど、重複があるのがわかる。
</script></section><section data-markdown><script type="text/template">
計算量は

$T(0)=1$ として

$$T(n)=1+\sum^{n-1}_{j=0}T(j)\ ...(15.3)$$

から

$T(n)=2^n$

- 指数関数オーダーになる。
- 演習問題のうち一つは、これを示しなさい、というもの。
</script></section></section><section ><section data-markdown><script type="text/template">
##### Using dynamic programming for optimal rod cutting 

- 解き方が2つ紹介されている。
- 再帰的なトップダウンのアプローチ
- ボトムアップなアプローチ
</script></section><section data-markdown><script type="text/template">
- 再帰的なトップダウンのアプローチ

![rec_top1](../images/algo/rod08.png)

- まずは $-\infty$ で配列を初期化、キャプチャして再帰関数を呼ぶ
- $-\infty$ は不明を表している。
</script></section><section data-markdown><script type="text/template">
![rec_top2](../images/algo/rod09.png)

- 部分問題の値を記録する
- トップダウンに、nから降りていく。
- 値が $-\infty$ 、不明の時は再帰呼び出し。
</script></section><section data-markdown><script type="text/template">
- ボトムアップなアプローチ
- 長さ1の場合から表をボトムアップに埋めていく

![bottom](../images/algo/rod10.png)
</script></section><section data-markdown><script type="text/template">
どちらも、長さn分最適値を考え、その度に平均 $n/2$ 候補を考えているため、計算量は $\Theta(n^2)$ となる。
</script></section></section><section ><section data-markdown><script type="text/template">
##### Subproblem graphs
</script></section><section data-markdown><script type="text/template">
rod cutting の例だと以下

<div style="display: inline;">

![rec_tree](../images/algo/rod07.png)

![rod_graph](../images/algo/rod11.png)

</div>

再帰呼び出しを木構造で表した図（左）をつぶしたもの。
</script></section><section data-markdown><script type="text/template">
- ボトムアップなアプローチは、トポロジカルソートの逆をたどっている
- 再帰的なトップダウンのDPは Subproblem graphs の深さ優先探索

と捉えられる。
</script></section><section data-markdown><script type="text/template">
- 頂点数が部分問題の数
- 辺の数が問題を解くために必要な時間

を表しているとして、計算量を考えられる。
</script></section></section><section ><section data-markdown><script type="text/template">
##### Reconstructing a solution 

切り方も一緒に返したい場合どうするか？
</script></section><section data-markdown><script type="text/template">
- 以下のような、最後に切った長さを保持する配列sを用意する。

![s](../images/algo/rod12.png)
</script></section><section data-markdown><script type="text/template">
- 長さnからsの値を繰り返し引いていけば、切り方を構成できる。

![how](../images/algo/rod13.png)
</script></section><section data-markdown><script type="text/template">
- sは以下のような拡張されたアルゴリズムで埋められる。

![s_algo](../images/algo/rod14.png)
</script></section></section><section ><section data-markdown><script type="text/template">
##### Exercises
</script></section><section data-markdown><script type="text/template">
###### 15.1-1 (15.3) と初期条件 $T(0)=1$ から (15.4) を導きなさい。
</script></section><section data-markdown><script type="text/template">
$T(0)=1$

$$T(n)=1+\sum^{n-1}_{j=0}T(j)\ ...(15.3)$$

から

$T(n)=2^n$

を導く。
</script></section><section data-markdown><script type="text/template">
差分を考えれば良い。

$T(n)-T(n-1)=T(n-1)$

$T(n)=2T(n-1)$

$\therefore T(n)=2^n$
</script></section></section><section ><section data-markdown><script type="text/template">
###### 15.1-2 反例を挙げることで、長さ $i$ の棒の **’密度’** を $p_i/i$ として、密度の高い順に切れるだけ切っていくという貪欲法が間違っているということを示しなさい。
</script></section><section data-markdown><script type="text/template">
$n = 18$

|length|1|9|10|
|:--|:--:|:--:|
|price|1|81|100|
|density|1|9|10|

$10 \times 10 + 1 \times 1 \times 8 < 2 \times 81 \times 2$
</script></section></section><section ><section data-markdown><script type="text/template">
###### 15.1-3 切断のたびにコスト $c$ がかかる場合の動的計画法のアルゴリズムを考えなさい。
</script></section><section data-markdown><script type="text/template">
切断しない場合以外は $c$ を引いた値で更新していけば良い。
</script></section></section><section ><section data-markdown><script type="text/template">
###### 15.1-4 MEMOIZED-CUT-ROD アルゴリズムを、値だけでなく実際の解（切り方）も返すように変更しなさい。
</script></section><section data-markdown><script type="text/template">
s[0..n] を初期化し、rと同じタイミングで更新。qが更新されたタイミングでsを記録していけば良い。
</script></section></section><section ><section data-markdown><script type="text/template">
###### 15.1-5 フィボナッチ数を動的計画法で解きなさい。 subproblem graph を書き、頂点と辺の数を求めなさい。
</script></section><section data-markdown><script type="text/template">
![subproblem graph](../images/algo/rod.png)

頂点 $n$ , 辺 $2(n-2)$
</script></section><section data-markdown><script type="text/template">
```
def fibonacci(n):
    F = [1,1]
    for i in range(1,n-1):
        F.append(F[i]+F[i-1])
    return F[-1]
```
</script></section></section></div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            function extend() {
              var target = {};
              for (var i = 0; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (source.hasOwnProperty(key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            }
            // Optional libraries used to extend on reveal.js
            var deps = [
              { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
              { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
              { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
              { src: 'plugin/math/math.js', async: true }
            ];
            // default options to init reveal.js
            var defaultOptions = {
              controls: true,
              progress: true,
              history: true,
              center: true,
              transition: 'default',
              dependencies: deps
            };
            // options from URL query string
            var queryOptions = Reveal.getQueryHash() || {};
            var options = {
  "notesSeparator": "note:",
  "separator": "^[\r\n?|\n]---[\r\n?|\n]$",
  "verticalSeparator": "^[\r\n?|\n]--[\r\n?|\n]$",
  "theme": "night",
  "highlightTheme": "Zenburn",
  "controls": true,
  "progress": true,
  "slideNumber": false,
  "history": true,
  "keyboard": true,
  "overview": true,
  "center": true,
  "touch": true,
  "loop": false,
  "rtl": false,
  "shuffle": false,
  "fragments": true,
  "embedded": false,
  "help": true,
  "showNotes": false,
  "autoSlide": 0,
  "autoSlideStoppable": true,
  "mouseWheel": false,
  "hideAddressBar": true,
  "previewLinks": true,
  "transition": "convex",
  "transitionSpeed": "default",
  "backgroundTransition": "convex",
  "viewDistance": 3,
  "parallaxBackgroundImage": "",
  "parallaxBackgroundSize": "",
  "parallaxBackgroundHorizontal": null,
  "parallaxBackgroundVertical": null,
  "attributes": ""
};
            options = extend(defaultOptions, options, queryOptions);
            Reveal.initialize(options);

        </script>
        
    </body>
</html>